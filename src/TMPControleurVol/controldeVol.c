#include "controldeVol.h"


void clean_args_CONTROLDEVOL(args_CONTROLDEVOL * arg){
	if (arg != NULL) {
		if (arg->motorsAll != NULL) {
			//clean_(arg->motorsAll);
		}
		if(arg->dataController != NULL){
			//clean(arg->dataController);
		}

		free(arg);
		arg=NULL;
	}
}

void * startCONTROLVOL(void * args){
    //On travaille sur les moteur 0 et 3
	args_CONTROLDEVOL  * controle_vol =(args_CONTROLDEVOL *)args;

	//int bool_stop=controle_vol->dataController->moteur_active;
	printf("THREAD CONTROLVOL START\n");
    uint64_t time_debut;
    uint64_t time_fin;
    uint64_t time_to_sleep;

    //Consigne client
    float client_gaz=1000;
    float client_roll=0;
    float client_pitch=0;
    float client_yaw=0;
    
    //PID
    float output_pid_roll=0;
    float output_pid_pitch=0;
    float output_pid_yaw=0;
    //erreur des PID
    float pid_erreur_tmp_roll=0;
    float pid_erreur_tmp_pitch=0;
    float pid_erreur_tmp_yaw=0;
    
    //erreur accu
    float pid_accu_erreur_roll=0;
    float pid_accu_erreur_pitch=0;
    float pid_accu_erreur_yaw=0;
    
    //last erreur
    float pid_last_roll=0;
    float pid_last_pitch=0;
    float pid_last_yaw=0;
    
    // puissance des 4 moteur. (en microseconde)
    int puissance_motor0=1000;
    int puissance_motor1=1000;
    int puissance_motor2=1000;
    int puissance_motor3=1000;
    
    
    
    //  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
    //  Or, you can create the .ini in some other directory by using:
    //      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
    //  where <directory path> is the path to where the .ini file is to be loaded/saved
    //TODO calibration.
    RTIMUSettings *settings = new RTIMUSettings("RTIMULib");
    
    RTIMU *imu = RTIMU::createIMU(settings);
    
    if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {
        printf("No IMU found\n");
        exit(1);
    }
    
    //  This is an opportunity to manually override any settings before the call IMUInit
    
    //  set up IMU
    
    imu->IMUInit();
    
    //  this is a convenient place to change fusion parameters
    
    imu->setSlerpPower(0.02);
    imu->setGyroEnable(true);
    imu->setAccelEnable(true);
    imu->setCompassEnable(true);
    
    while (1) {
        time_debut=RTMath::currentUSecsSinceEpoch();
        //  poll at the rate recommended by the IMU
        if(!imu->IMURead()){
            //Probleme de l'ecture sur le capteur.
            printf("PROBLEME DE LECTURE SUR LE CAPTEUR.");
        }
        RTIMU_DATA imuData = imu->getIMUData();
        
        //calcule roll PID
        pid_erreur_tmp_roll=(imuData.fusionPose.x()*RTMATH_RAD_TO_DEGREE)-client_roll;
        pid_accu_erreur_roll+=PID_GAIN_I_ROLL*pid_erreur_tmp_roll;
        //Si on depasse l'accumulation max.
        if (pid_accu_erreur_roll>PID_MAX_ROLL) {
            pid_accu_erreur_roll=PID_MAX_ROLL;
        }
        else if (pid_accu_erreur_roll < -PID_MAX_ROLL){
            pid_accu_erreur_roll=-PID_MAX_ROLL;
        }
        
        output_pid_roll=PID_GAIN_P_ROLL*pid_erreur_tmp_roll+pid_accu_erreur_roll+PID_GAIN_D_ROLL*(pid_erreur_tmp_roll-pid_last_roll);
        if (output_pid_roll>PID_MAX_ROLL) {
            output_pid_roll=PID_MAX_ROLL;
        }
        else if (output_pid_roll< -PID_MAX_ROLL){
            output_pid_roll=-PID_MAX_ROLL;
        }
        //l'erreur actuel devien la derniere.
        pid_last_roll=pid_erreur_tmp_roll;
        
        
        
        //calcule pitch PID
        pid_erreur_tmp_pitch=(imuData.fusionPose.y()*RTMATH_RAD_TO_DEGREE)-client_pitch;
        pid_accu_erreur_pitch+=PID_GAIN_I_PITCH*pid_erreur_tmp_pitch;
        if (pid_accu_erreur_pitch>PID_MAX_PITCH) {
            pid_accu_erreur_pitch=PID_MAX_PITCH;
        }
        else if (pid_accu_erreur_pitch < -PID_MAX_PITCH){
            pid_accu_erreur_pitch=-PID_MAX_PITCH;
        }
        
        output_pid_pitch=PID_GAIN_P_PITCH*pid_erreur_tmp_pitch+pid_accu_erreur_pitch+PID_GAIN_D_PITCH*(pid_erreur_tmp_pitch-pid_last_pitch);
        
        if (output_pid_pitch>PID_MAX_PITCH) {
            output_pid_pitch=PID_MAX_PITCH;
        }
        else if (output_pid_pitch < -PID_MAX_PITCH){
            output_pid_pitch=-PID_MAX_PITCH;
        }
        pid_last_pitch=pid_erreur_tmp_pitch;
        
        //calcule yaw PID
        pid_erreur_tmp_yaw=(imuData.fusionPose.z()*RTMATH_RAD_TO_DEGREE)-client_yaw;
        pid_accu_erreur_pitch+=PID_GAIN_I_YAW*pid_erreur_tmp_yaw;
        if(pid_accu_erreur_yaw>PID_MAX_YAW){
            pid_accu_erreur_yaw=PID_MAX_YAW;
        }
        else if(pid_accu_erreur_yaw<-PID_MAX_YAW){
            pid_accu_erreur_yaw=-PID_MAX_YAW;
        }
        
        output_pid_yaw=PID_GAIN_P_YAW*pid_erreur_tmp_yaw+pid_accu_erreur_yaw+PID_GAIN_D_YAW*(pid_erreur_tmp_yaw-pid_last_yaw);
        if(output_pid_yaw>PID_MAX_YAW){
            output_pid_yaw=PID_MAX_YAW;
        }
        else if(output_pid_yaw<-PID_MAX_YAW){
            output_pid_yaw=-PID_MAX_YAW;
        }
        pid_last_yaw=pid_erreur_tmp_yaw;
        
        puissance_motor0=client_gaz - output_pid_pitch + output_pid_roll - output_pid_yaw;
        puissance_motor1=client_gaz + output_pid_pitch + output_pid_roll + output_pid_yaw;
        puissance_motor2=client_gaz + output_pid_pitch - output_pid_roll - output_pid_yaw;
        puissance_motor3=client_gaz - output_pid_pitch - output_pid_roll + output_pid_yaw;
        //Pour jamais mettre a l'arret les moteur.
        if(puissance_motor0<1100) puissance_motor0=1100;
        if(puissance_motor1<1100) puissance_motor1=1100;
        if(puissance_motor2<1100) puissance_motor2=1100;
        if(puissance_motor3<1100) puissance_motor3=1100;
        
        //puissance max=2000 donc il faut pas depasser.
        if(puissance_motor0>2000) puissance_motor0=2000;
        if(puissance_motor1>2000) puissance_motor1=2000;
        if(puissance_motor2>2000) puissance_motor2=2000;
        if(puissance_motor3>2000) puissance_motor3=2000;
        
        //set la puissance au moteur.
        set_power(controle_vol->motorsAll->motor0,puissance_motor0);
        set_power(controle_vol->motorsAll->motor1, puissance_motor1);
        set_power(controle_vol->motorsAll->motor2, puissance_motor2);
        set_power(controle_vol->motorsAll->motor3, puissance_motor3);
        
        time_fin=RTMath::currentUSecsSinceEpoch();
        time_to_sleep=4000-(time_fin-time_debut);
        if(time_to_sleep>0){
            usleep(time_to_sleep);
        }
        else{
            printf("ON EST TROP LENT...\n");
        }
    }
    return NULL;
}
void init_threads_controle(args_CONTROLDEVOL  * controle_vol){
    cpu_set_t cpuset;//ensemble des CPU utilisable.
    
    pthread_t thr0;
    pthread_attr_t attributs;
    
    struct sched_param parametres;
    
    
    //Definir la taille de la memoire virtuelle pour que le kernel de fasse pas d'allocation dynamique.
    mlockall(MCL_CURRENT | MCL_FUTURE);
    
    
    
    //init avec les attributs par defaut.
    pthread_attr_init(& attributs);
    
    //TODO CODE RASPBERRY
    //Mettre Sur un coeur ici le coeur 0;
    CPU_ZERO(& cpuset);//mes lensemble a vide
    CPU_SET(1,& cpuset);//ajoute i a lensemble des CPU
    //fixer l'affinity
    pthread_attr_setaffinity_np(& attributs, sizeof(cpu_set_t), & cpuset);
    
    //Priorite temps reel.
    parametres.sched_priority=99; //choisir le prioroté (de 0 a 99)
    pthread_attr_setschedpolicy(&attributs,SCHED_FIFO);//Inscrire le type d ordonnancement voulu dans les attribue.
    pthread_attr_setschedparam(&attributs,&parametres); //incrire la priorite dans les attributs.
    pthread_attr_setinheritsched(&attributs,PTHREAD_EXPLICIT_SCHED); //chaque aura sa propre priorité.
    pthread_attr_setscope(&attributs,PTHREAD_SCOPE_SYSTEM); // Pour ne pas etre preemte par des processus du system
    
    
    
    //creation du thread.
    if (pthread_create(&thr0, &attributs, startCONTROLVOL, controle_vol)) {
        perror("pthread0_create");
    }
    
    pthread_attr_destroy(&attributs);//Libere les resource.
    
}
